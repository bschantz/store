{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","../../../../packages/router-plugin/src/router.actions.ts","../../../../packages/router-plugin/src/serializer.ts","../../../../packages/router-plugin/src/router.state.ts","../../../../packages/router-plugin/src/router.module.ts"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__metadata","metadataKey","metadataValue","metadata","Navigate","path","queryParams","extras","this","RouterNavigation","routerState","event","trigger","RouterCancel","storeState","RouterError","RouterDataResolved","DefaultRouterStateSerializer","prototype","serialize","root","serializeRoute","url","route","_this","children","map","params","fragment","data","outlet","component","routeConfig","parent","firstChild","pathFromRoot","paramMap","queryParamMap","toString","RouterState","RouterState_1","_store","_router","_serializer","_ngZone","_urlSerializer","_locationStrategy","_location","_trigger","_routerState","_storeState","_lastRoutesRecognized","setUpStoreListener","setUpRouterEventsListener","checkInitialNavigationOnce","state","navigate","_","action","run","assign","angularRouterAction","ctx","setState","getState","navigationId","id","select","subscribe","navigateIfNeeded","events","NavigationStart","navigationStart","RoutesRecognized","ResolveEnd","dispatchRouterDataResolved","NavigationCancel","dispatchRouterCancel","reset","NavigationError","dispatchRouterError","NavigationEnd","navigationEnd","snapshot","selectSnapshot","shouldDispatchRouterNavigation","dispatchRouterNavigation","navigateByUrl","nextRouterState","dispatchRouterAction","urlAfterRedirects","dispatch","isAngularInTestMode","pipe","first","_a","currentUrl","normalize","currentUrlTree","parse","Injectable","Store","Router","RouterStateSerializer","NgZone","UrlSerializer","LocationStrategy","Location","Action","Selector","State","name","defaults","undefined","NgxsRouterPluginModule","forRoot","ngModule","providers","provide","useClass","NgModule","args","imports","NgxsModule","forFeature"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {\n  NavigationCancel,\n  NavigationError,\n  NavigationExtras,\n  Params,\n  RouterStateSnapshot,\n  RoutesRecognized,\n  ResolveEnd\n} from '@angular/router';\n\nimport { RouterTrigger } from './router.state';\n\n/**\n * Public event api of the router\n */\nexport class Navigate {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] Navigate';\n  }\n  constructor(\n    public path: any[],\n    public queryParams?: Params,\n    public extras?: NavigationExtras\n  ) {}\n}\n\n/**\n *\n * Angular Routers internal state events\n *\n */\n\n/**\n * An action dispatched when the router navigates.\n */\nexport class RouterNavigation<T = RouterStateSnapshot> {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] RouterNavigation';\n  }\n  constructor(\n    public routerState: T,\n    public event: RoutesRecognized,\n    public trigger: RouterTrigger = 'none'\n  ) {}\n}\n\n/**\n * An action dispatched when the router cancel navigation.\n */\nexport class RouterCancel<T, V = RouterStateSnapshot> {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] RouterCancel';\n  }\n  constructor(\n    public routerState: V,\n    public storeState: T,\n    public event: NavigationCancel,\n    public trigger: RouterTrigger = 'none'\n  ) {}\n}\n\n/**\n * An action dispatched when the router errors.\n */\nexport class RouterError<T, V = RouterStateSnapshot> {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] RouterError';\n  }\n  constructor(\n    public routerState: V,\n    public storeState: T,\n    public event: NavigationError,\n    public trigger: RouterTrigger = 'none'\n  ) {}\n}\n\n/**\n * An action dispatched when the `ResolveEnd` event is triggered.\n */\nexport class RouterDataResolved<T = RouterStateSnapshot> {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '[Router] RouterDataResolved';\n  }\n  constructor(\n    public routerState: T,\n    public event: ResolveEnd,\n    public trigger: RouterTrigger = 'none'\n  ) {}\n}\n\n/**\n * An union type of router actions.\n */\nexport type RouterAction<T, V = RouterStateSnapshot> =\n  | RouterNavigation<V>\n  | RouterCancel<T, V>\n  | RouterError<T, V>\n  | RouterDataResolved<V>;\n","import { ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\n\nexport abstract class RouterStateSerializer<T> {\n  abstract serialize(routerState: RouterStateSnapshot): T;\n}\n\nexport interface SerializedRouterStateSnapshot {\n  root: ActivatedRouteSnapshot;\n  url: string;\n}\n\nexport class DefaultRouterStateSerializer\n  implements RouterStateSerializer<SerializedRouterStateSnapshot> {\n  serialize(routerState: RouterStateSnapshot): SerializedRouterStateSnapshot {\n    return {\n      root: this.serializeRoute(routerState.root),\n      url: routerState.url\n    };\n  }\n\n  private serializeRoute(route: ActivatedRouteSnapshot): ActivatedRouteSnapshot {\n    const children = route.children.map(c => this.serializeRoute(c));\n    return {\n      url: route.url,\n      params: route.params,\n      queryParams: route.queryParams,\n      fragment: route.fragment,\n      data: route.data,\n      outlet: route.outlet,\n      component: null,\n      routeConfig: null,\n      root: null as any,\n      parent: null,\n      firstChild: children[0],\n      children: children,\n      pathFromRoot: null as any,\n      paramMap: route.paramMap,\n      queryParamMap: route.queryParamMap,\n      toString: route.toString\n    };\n  }\n}\n","import { NgZone, Injectable } from '@angular/core';\nimport {\n  NavigationCancel,\n  NavigationError,\n  Router,\n  RouterStateSnapshot,\n  RoutesRecognized,\n  ResolveEnd,\n  UrlSerializer,\n  NavigationStart,\n  NavigationEnd\n} from '@angular/router';\nimport { LocationStrategy, Location } from '@angular/common';\nimport { Action, Selector, State, StateContext, Store } from '@ngxs/store';\nimport { isAngularInTestMode } from '@ngxs/store/internals';\nimport { first } from 'rxjs/operators';\n\nimport {\n  Navigate,\n  RouterAction,\n  RouterCancel,\n  RouterError,\n  RouterNavigation,\n  RouterDataResolved\n} from './router.actions';\nimport { RouterStateSerializer } from './serializer';\n\nexport interface RouterStateModel<T = RouterStateSnapshot> {\n  state?: T;\n  navigationId?: number;\n  trigger: RouterTrigger;\n}\n\nexport type RouterTrigger = 'none' | 'router' | 'store';\n\n@State<RouterStateModel>({\n  name: 'router',\n  defaults: {\n    state: undefined,\n    navigationId: undefined,\n    trigger: 'none'\n  }\n})\n@Injectable()\nexport class RouterState {\n  /**\n   * Determines how navigation was performed by the `RouterState` itself\n   * or outside via `new Navigate(...)`\n   */\n  private _trigger: RouterTrigger = 'none';\n\n  /**\n   * That's the serialized state from the `Router` class\n   */\n  private _routerState: RouterStateSnapshot | null = null;\n\n  /**\n   * That's the value of the `RouterState` state\n   */\n  private _storeState: RouterStateModel | null = null;\n\n  private _lastRoutesRecognized: RoutesRecognized = null!;\n\n  @Selector()\n  static state<T = RouterStateSnapshot>(state: RouterStateModel<T>) {\n    return state && state.state;\n  }\n\n  @Selector()\n  static url(state: RouterStateModel): string | undefined {\n    return state && state.state && state.state.url;\n  }\n\n  constructor(\n    private _store: Store,\n    private _router: Router,\n    private _serializer: RouterStateSerializer<RouterStateSnapshot>,\n    private _ngZone: NgZone,\n    private _urlSerializer: UrlSerializer,\n    private _locationStrategy: LocationStrategy,\n    private _location: Location\n  ) {\n    this.setUpStoreListener();\n    this.setUpRouterEventsListener();\n    this.checkInitialNavigationOnce();\n  }\n\n  @Action(Navigate)\n  navigate(_: StateContext<RouterStateModel>, action: Navigate) {\n    return this._ngZone.run(() =>\n      this._router.navigate(action.path, {\n        queryParams: action.queryParams,\n        ...action.extras\n      })\n    );\n  }\n\n  @Action([RouterNavigation, RouterError, RouterCancel, RouterDataResolved])\n  angularRouterAction(\n    ctx: StateContext<RouterStateModel>,\n    action: RouterAction<RouterStateModel, RouterStateSnapshot>\n  ): void {\n    ctx.setState({\n      ...ctx.getState(),\n      trigger: action.trigger,\n      state: action.routerState,\n      navigationId: action.event.id\n    });\n  }\n\n  private setUpStoreListener(): void {\n    this._store.select(RouterState).subscribe((state: RouterStateModel | undefined) => {\n      this.navigateIfNeeded(state);\n    });\n  }\n\n  private setUpRouterEventsListener(): void {\n    this._router.events.subscribe(event => {\n      if (event instanceof NavigationStart) {\n        this.navigationStart();\n      } else if (event instanceof RoutesRecognized) {\n        this._lastRoutesRecognized = event;\n      } else if (event instanceof ResolveEnd) {\n        this.dispatchRouterDataResolved(event);\n      } else if (event instanceof NavigationCancel) {\n        this.dispatchRouterCancel(event);\n        this.reset();\n      } else if (event instanceof NavigationError) {\n        this.dispatchRouterError(event);\n        this.reset();\n      } else if (event instanceof NavigationEnd) {\n        this.navigationEnd();\n        this.reset();\n      }\n    });\n  }\n\n  private navigationStart(): void {\n    this._routerState = this._serializer.serialize(this._router.routerState.snapshot);\n\n    if (this._trigger !== 'none') {\n      this._storeState = this._store.selectSnapshot(RouterState);\n    }\n  }\n\n  private navigationEnd(): void {\n    if (this.shouldDispatchRouterNavigation()) {\n      this.dispatchRouterNavigation();\n    }\n  }\n\n  private shouldDispatchRouterNavigation(): boolean {\n    if (!this._storeState) return true;\n    return this._trigger !== 'store';\n  }\n\n  private navigateIfNeeded(state: RouterStateModel | undefined): void {\n    const canSkipNavigation =\n      !this._storeState ||\n      !this._storeState.state ||\n      !state ||\n      state.trigger === 'router' ||\n      this._router.url === this._storeState.state.url;\n\n    if (canSkipNavigation) {\n      return;\n    }\n\n    this._trigger = 'store';\n    this._ngZone.run(() => {\n      this._router.navigateByUrl(this._storeState!.state!.url);\n    });\n  }\n\n  private dispatchRouterNavigation(): void {\n    const nextRouterState = this._serializer.serialize(this._lastRoutesRecognized.state);\n\n    this.dispatchRouterAction(\n      new RouterNavigation(\n        nextRouterState,\n        new RoutesRecognized(\n          this._lastRoutesRecognized.id,\n          this._lastRoutesRecognized.url,\n          this._lastRoutesRecognized.urlAfterRedirects,\n          nextRouterState\n        ),\n        this._trigger\n      )\n    );\n  }\n\n  private dispatchRouterCancel(event: NavigationCancel): void {\n    this.dispatchRouterAction(\n      new RouterCancel(this._routerState!, this._storeState, event, this._trigger)\n    );\n  }\n\n  private dispatchRouterError(event: NavigationError): void {\n    this.dispatchRouterAction(\n      new RouterError(\n        this._routerState!,\n        this._storeState,\n        new NavigationError(event.id, event.url, `${event}`),\n        this._trigger\n      )\n    );\n  }\n\n  private dispatchRouterAction<T>(action: RouterAction<T>): void {\n    this._trigger = 'router';\n\n    try {\n      this._store.dispatch(action);\n    } finally {\n      this._trigger = 'none';\n    }\n  }\n\n  private dispatchRouterDataResolved(event: ResolveEnd): void {\n    const routerState = this._serializer.serialize(event.state);\n    this.dispatchRouterAction(new RouterDataResolved(routerState, event, this._trigger));\n  }\n\n  private reset(): void {\n    this._trigger = 'none';\n    this._storeState = null;\n    this._routerState = null;\n  }\n\n  /**\n   * No sense to mess up the `setUpRouterEventsListener` method as we have\n   * to perform this check only once and unsubscribe after the first event\n   * is triggered\n   */\n  private checkInitialNavigationOnce(): void {\n    if (isAngularInTestMode()) {\n      return;\n    }\n\n    this._router.events\n      .pipe(first((event): event is RoutesRecognized => event instanceof RoutesRecognized))\n      .subscribe(({ url }) => {\n        // `location.pathname` always equals manually entered URL in the address bar\n        // e.g. `location.pathname === '/foo'`, but the `router` state has been initialized\n        // with another URL (e.g. used in combination with `NgxsStoragePlugin`), thus the\n        // `RouterNavigation` action will be dispatched and the user will be redirected to the\n        // previously saved URL. We want to prevent such behavior, so we perform this check\n\n        // `url` is a recognized URL by the Angular's router, while `currentUrl` is an actual URL\n        // entered in the browser's address bar\n        // `PathLocationStrategy.prototype.path()` returns a concatenation of\n        // `PlatformLocation.pathname` and normalized `PlatformLocation.search`.\n\n        // `Location.prototype.normalize` strips base href from the URL,\n        // if `baseHref` (declared in angular.json) for example is `/en`\n        // and the URL is `/test#anchor` - then `_locationStrategy.path(true)` will return `/en/test#anchor`,\n        // but `/en/test#anchor` is not known to the Angular's router, so we have to strip `/en`\n        // from the URL\n        const currentUrl = this._location.normalize(this._locationStrategy.path(true));\n        const currentUrlTree = this._urlSerializer.parse(currentUrl);\n        // We need to serialize the URL because in that example `/test/?redirect=https://google.com/`\n        // Angular will recognize it as `/test?redirect=https:%2F%2Fwww.google.com%2F`\n        // so we have to run the `currentUrl` via the `UrlSerializer` that will encode characters\n        const currentSerializedUrl = this._urlSerializer.serialize(currentUrlTree);\n\n        // If URLs differ from each other - we've got to perform a redirect to the manually entered URL\n        // in the address bar, as it must have a priority\n        if (currentSerializedUrl !== url) {\n          this._router.navigateByUrl(currentUrl);\n        }\n      });\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { NgxsModule } from '@ngxs/store';\n\nimport { RouterState } from './router.state';\nimport { DefaultRouterStateSerializer, RouterStateSerializer } from './serializer';\n\n@NgModule({\n  imports: [NgxsModule.forFeature([RouterState])]\n})\nexport class NgxsRouterPluginModule {\n  static forRoot(): ModuleWithProviders<NgxsRouterPluginModule> {\n    return {\n      ngModule: NgxsRouterPluginModule,\n      providers: [{ provide: RouterStateSerializer, useClass: DefaultRouterStateSerializer }]\n    };\n  }\n}\n"]}